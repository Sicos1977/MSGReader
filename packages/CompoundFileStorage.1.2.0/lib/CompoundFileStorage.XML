<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CompoundFileStorage</name>
    </assembly>
    <members>
        <member name="T:CompoundFileStorage.BinaryTree.BinarySearchTree`1">
            <summary>
                Represents a binary search tree. A binary search tree is a binary tree whose nodes are arranged
                such that for any given node k, all nodes in k's left subtree have a value less than k, and all
                nodes in k's right subtree have a value greater than k.
            </summary>
            <typeparam name="T">The type of data stored in the binary tree nodes.</typeparam>
        </member>
        <member name="F:CompoundFileStorage.BinaryTree.BinarySearchTree`1._comparer">
            <summary>
                Used to compare node values when percolating down the tree
            </summary>
        </member>
        <member name="M:CompoundFileStorage.BinaryTree.BinarySearchTree`1.Clear">
            <summary>
                Removes the contents of the BST
            </summary>
        </member>
        <member name="M:CompoundFileStorage.BinaryTree.BinarySearchTree`1.CopyTo(`0[],System.Int32)">
            <summary>
                Copies the contents of the BST to an appropriately-sized array of type T, using the Inorder
                traversal method.
            </summary>
        </member>
        <member name="M:CompoundFileStorage.BinaryTree.BinarySearchTree`1.CopyTo(`0[],System.Int32,CompoundFileStorage.BinaryTree.TraversalMethod)">
            <summary>
                Copies the contents of the BST to an appropriately-sized array of type T, using a specified
                traversal method.
            </summary>
        </member>
        <member name="M:CompoundFileStorage.BinaryTree.BinarySearchTree`1.Add(`0)">
            <summary>
                Adds a new value to the BST.
            </summary>
            <param name="data">The data to insert into the BST.</param>
            <remarks>
                Adding a value already in the BST has no effect; that is, the SkipList is not
                altered, the Add() method simply exits.
            </remarks>
        </member>
        <member name="M:CompoundFileStorage.BinaryTree.BinarySearchTree`1.Contains(`0)">
            <summary>
                Returns a Boolean, indicating if a specified value is contained within the BST.
            </summary>
            <param name="data">The data to search for.</param>
            <returns>True if data is found in the BST; false otherwise.</returns>
        </member>
        <member name="M:CompoundFileStorage.BinaryTree.BinarySearchTree`1.TryFind(`0,`0@)">
            <summary>
                Returns a boolean, indicating if a specified value is contained within the BST.
            </summary>
            <param name="data">The data to search for.</param>
            <param name="foundObject"></param>
            <returns>True if data is found in the BST; false otherwise.</returns>
        </member>
        <member name="M:CompoundFileStorage.BinaryTree.BinarySearchTree`1.Remove(`0)">
            <summary>
                Attempts to remove the specified data element from the BST.
            </summary>
            <param name="data">The data to remove from the BST.</param>
            <returns>
                True if the element is found in the tree, and removed; false if the element is not
                found in the tree.
            </returns>
        </member>
        <member name="M:CompoundFileStorage.BinaryTree.BinarySearchTree`1.GetEnumerator">
            <summary>
                Enumerates the BST's contents using inorder traversal.
            </summary>
            <returns>An enumerator that provides inorder access to the BST's elements.</returns>
        </member>
        <member name="M:CompoundFileStorage.BinaryTree.BinarySearchTree`1.GetEnumerator(CompoundFileStorage.BinaryTree.TraversalMethod)">
            <summary>
                Enumerates the BST's contents using a specified traversal method.
            </summary>
            <param name="traversalMethod">The type of traversal to perform.</param>
            <returns>An enumerator that provides access to the BST's elements using a specified traversal technique.</returns>
        </member>
        <member name="P:CompoundFileStorage.BinaryTree.BinarySearchTree`1.Preorder">
            <summary>
                Provides enumeration through the BST using preorder traversal.
            </summary>
        </member>
        <member name="P:CompoundFileStorage.BinaryTree.BinarySearchTree`1.Inorder">
            <summary>
                Provides enumeration through the BST using inorder traversal.
            </summary>
        </member>
        <member name="P:CompoundFileStorage.BinaryTree.BinarySearchTree`1.Postorder">
            <summary>
                Provides enumeration through the BST using postorder traversal.
            </summary>
        </member>
        <member name="P:CompoundFileStorage.BinaryTree.BinarySearchTree`1.Count">
            <summary>
                Returns the number of elements in the BST.
            </summary>
        </member>
        <member name="T:CompoundFileStorage.BinaryTree.BinaryTreeNode`1">
            <summary>
                The BinaryTreeNode class represents a node in a binary tree, or a binary search tree.
                It has precisely two neighbors, which can be accessed via the Left and Right properties.
            </summary>
            <typeparam name="T">The type of data stored in the binary tree node.</typeparam>
        </member>
        <member name="T:CompoundFileStorage.BinaryTree.Node`1">
            <summary>
                The Node&lt;T&gt; class represents the base concept of a Node for a tree or graph.  It contains
                a data item of type T, and a list of neighbors.
            </summary>
            <typeparam name="T">The type of data contained in the Node.</typeparam>
            <remarks>
                None of the classes in the SkmDataStructures2 namespace use the Node class directly;
                they all derive from this class, adding necessary functionality specific to each data structure.
            </remarks>
        </member>
        <member name="T:CompoundFileStorage.BinaryTree.NodeList`1">
            <summary>
                Represents a collection of Node&lt;T&gt; instances.
            </summary>
            <typeparam name="T">The type of data held in the Node instances referenced by this class.</typeparam>
        </member>
        <member name="M:CompoundFileStorage.BinaryTree.NodeList`1.FindByValue(`0)">
            <summary>
                Searches the NodeList for a Node containing a particular value.
            </summary>
            <param name="value">The value to search for.</param>
            <returns>The Node in the NodeList, if it exists; null otherwise.</returns>
        </member>
        <member name="T:CompoundFileStorage.BinaryTree.TraversalMethod">
            <summary>
            Provides the set of values by which a binary search tree can be enumerated.
            </summary>
        </member>
        <member name="T:CompoundFileStorage.CFItem">
            <summary>
                Abstract base class for Structured Storage entities.
            </summary>
        </member>
        <member name="T:CompoundFileStorage.Interfaces.ICFItem">
            <summary>
                The compound file item interface
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Interfaces.ICFItem.Name">
            <summary>
                Get entity name
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Interfaces.ICFItem.Size">
            <summary>
                Size in bytes of the item. It has a valid value
                only if entity is a stream, otherwise it is setted to zero.
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Interfaces.ICFItem.IsStorage">
            <summary>
                Return true if item is Storage
            </summary>
            <remarks>
                This check doesn't use reflection or runtime type information
                and doesn't suffer related performance penalties.
            </remarks>
        </member>
        <member name="P:CompoundFileStorage.Interfaces.ICFItem.IsStream">
            <summary>
                Return true if item is a Stream
            </summary>
            <remarks>
                This check doesn't use reflection or runtime type information
                and doesn't suffer related performance penalties.
            </remarks>
        </member>
        <member name="P:CompoundFileStorage.Interfaces.ICFItem.IsRoot">
            <summary>
                Return true if item is the Root Storage
            </summary>
            <remarks>
                This check doesn't use reflection or runtime type information
                and doesn't suffer related performance penalties.
            </remarks>
        </member>
        <member name="P:CompoundFileStorage.Interfaces.ICFItem.CreationDate">
            <summary>
                Get/Set the Creation Date of the current item
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Interfaces.ICFItem.ModifyDate">
            <summary>
                Get/Set the Modify Date of the current item
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Interfaces.ICFItem.CLSID">
            <summary>
                Get/Set Object class Guid for Root and Storage entries.
            </summary>
        </member>
        <member name="P:CompoundFileStorage.CFItem.Name">
            <summary>
                Get entity name
            </summary>
        </member>
        <member name="P:CompoundFileStorage.CFItem.Size">
            <summary>
                Size in bytes of the item. It has a valid value
                only if entity is a stream, otherwise it is setted to zero.
            </summary>
        </member>
        <member name="P:CompoundFileStorage.CFItem.IsStorage">
            <summary>
                Returns true if item is Storage
            </summary>
            <remarks>
                This check doesn't use reflection or runtime type information
                and doesn't suffer related performance penalties.
            </remarks>
        </member>
        <member name="P:CompoundFileStorage.CFItem.IsStream">
            <summary>
                Returns true if item is a Stream
            </summary>
            <remarks>
                This check doesn't use reflection or runtime type information
                and doesn't suffer related performance penalties.
            </remarks>
        </member>
        <member name="P:CompoundFileStorage.CFItem.IsRoot">
            <summary>
                Returnstrue if item is the Root Storage
            </summary>
            <remarks>
                This check doesn't use reflection or runtime type information
                and doesn't suffer related performance penalties.
            </remarks>
        </member>
        <member name="P:CompoundFileStorage.CFItem.CreationDate">
            <summary>
                Get/Set the Creation Date of the current item
            </summary>
        </member>
        <member name="P:CompoundFileStorage.CFItem.ModifyDate">
            <summary>
                Get/Set the Modify Date of the current item
            </summary>
        </member>
        <member name="P:CompoundFileStorage.CFItem.CLSID">
            <summary>
                Get/Set Object class Guid for Root and Storage entries.
            </summary>
        </member>
        <member name="T:CompoundFileStorage.CFMock">
            <summary>
                Used as internal template object for binary tree searches.
            </summary>
        </member>
        <member name="T:CompoundFileStorage.CFStorage">
            <summary>
                Storage entity that acts like a logic container for streams or substorages in a compound file.
            </summary>
        </member>
        <member name="T:CompoundFileStorage.Interfaces.ICFStorage">
            <summary>
                The compound file storage interface
            </summary>
        </member>
        <member name="M:CompoundFileStorage.Interfaces.ICFStorage.GetStream(System.String)">
            <summary>
                Gets a named
                <see cref="T:DocumentServices.Modules.Extractors.OfficeExtractor.OLECompoundFileStorage.CFStream">stream</see>
                contained in the current storage if existing.
            </summary>
            <param name="streamName">Name of the stream to look for</param>
            <returns>A stream reference if existing</returns>
            <exception cref="T:DocumentServices.Modules.Extractors.OfficeExtractor.OLECompoundFileStorage.CFDisposedException">
                Raised
                if trying to delete item from a closed compound file
            </exception>
            <exception cref="T:DocumentServices.Modules.Extractors.OfficeExtractor.OLECompoundFileStorage.CFItemNotFound">
                Raised if
                item to delete is not found
            </exception>
            <example>
                <code>
             String filename = "report.xls";
            
             CompoundFile cf = new CompoundFile(filename);
             CFStream foundStream = cf.RootStorage.GetStream("Workbook");
            
             byte[] temp = foundStream.GetData();
            
             Assert.IsNotNull(temp);
            
             cf.Close();
             </code>
            </example>
        </member>
        <member name="M:CompoundFileStorage.Interfaces.ICFStorage.ExistsStream(System.String)">
            <summary>
                Checks whether a child stream exists in the parent.
            </summary>
            <param name="streamName">Name of the stream to look for</param>
            <returns>A boolean value indicating whether the child stream exists.</returns>
            <example>
                <code>
             string filename = "report.xls";
            
             CompoundFile cf = new CompoundFile(filename);
             
             bool exists = ExistsStream("Workbook");
             
             if exists
             {
                 CFStream foundStream = cf.RootStorage.GetStream("Workbook");
             
                 byte[] temp = foundStream.GetData();
             }
            
             Assert.IsNotNull(temp);
            
             cf.Close();
             </code>
            </example>
        </member>
        <member name="M:CompoundFileStorage.Interfaces.ICFStorage.GetStorage(System.String)">
            <summary>
                Gets a named storage contained in the current one if existing.
            </summary>
            <param name="storageName">Name of the storage to look for</param>
            <returns>A storage reference if existing.</returns>
            <exception cref="T:DocumentServices.Modules.Extractors.OfficeExtractor.OLECompoundFileStorage.CFDisposedException">
                Raised
                if trying to delete item from a closed compound file
            </exception>
            <exception cref="T:DocumentServices.Modules.Extractors.OfficeExtractor.OLECompoundFileStorage.CFItemNotFound">
                Raised if item to delete is not found
            </exception>
            <example>
                <code>
             
             string FILENAME = "MultipleStorage2.cfs";
             CompoundFile cf = new CompoundFile(FILENAME);
            
             CFStorage st = cf.RootStorage.GetStorage("MyStorage");
            
             Assert.IsNotNull(st);
             cf.Close();
             </code>
            </example>
        </member>
        <member name="M:CompoundFileStorage.Interfaces.ICFStorage.ExistsStorage(System.String)">
            <summary>
                Checks if a child storage exists within the parent.
            </summary>
            <param name="storageName">Name of the storage to look for.</param>
            <returns>A boolean value indicating whether the child storage was found.</returns>
            <example>
                <code>
             string FILENAME = "MultipleStorage2.cfs";
             CompoundFile cf = new CompoundFile(FILENAME, UpdateMode.ReadOnly, false, false);
            
             bool exists = cf.RootStorage.ExistsStorage("MyStorage");
             
             if exists
             {
                 CFStorage st = cf.RootStorage.GetStorage("MyStorage");
             }
             
             Assert.IsNotNull(st);
             cf.Close();
             </code>
            </example>
        </member>
        <member name="M:CompoundFileStorage.CFStorage.#ctor(CompoundFileStorage.CompoundFile)">
            <summary>
                Create a new CFStorage
            </summary>
            <param name="compFile">The Storage Owner - CompoundFile</param>
        </member>
        <member name="M:CompoundFileStorage.CFStorage.#ctor(CompoundFileStorage.CompoundFile,CompoundFileStorage.Interfaces.IDirectoryEntry)">
            <summary>
                Create a CFStorage using an existing directory (previously loaded).
            </summary>
            <param name="compFile">The Storage Owner - CompoundFile</param>
            <param name="dirEntry">An existing Directory Entry</param>
        </member>
        <member name="M:CompoundFileStorage.CFStorage.GetStream(System.String)">
            <summary>
                Get a named
                <see cref="T:DocumentServices.Modules.Extractors.OfficeExtractor.OLECompoundFileStorage.CFStream">stream</see>
                contained in the current storage if existing.
            </summary>
            <param name="streamName">Name of the stream to look for</param>
            <returns>A stream reference if existing</returns>
            <exception cref="T:CompoundFileStorage.Exceptions.CFItemNotFound">Raised if <see cref="!:streamName"/> is not found</exception>
        </member>
        <member name="M:CompoundFileStorage.CFStorage.AddStream(System.String)">
            <summary>
                Create a new child stream inside the current <see cref="T:OpenMcdf.CFStorage">storage</see>
            </summary>
            <param name="streamName">The new stream name</param>
            <returns>The new <see cref="T:OpenMcdf.CFStream">stream</see> reference</returns>
            <exception cref="T:CompoundFileStorage.Exceptions.CFDuplicatedItemException">Raised when adding an item with the same name of an existing one</exception>
            <exception cref="T:CompoundFileStorage.Exceptions.CFDisposedException">Raised when adding a stream to a closed compound file</exception>
            <exception cref="T:CompoundFileStorage.Exceptions.CFException">Raised when adding a stream with null or empty name</exception>
            <example>
                <code>
             
              String filename = "A_NEW_COMPOUND_FILE_YOU_CAN_WRITE_TO.cfs";
            
              CompoundFile cf = new CompoundFile();
            
              CFStorage st = cf.RootStorage.AddStorage("MyStorage");
              CFStream sm = st.AddStream("MyStream");
              byte[] b = Helpers.GetBuffer(220, 0x0A);
              sm.SetData(b);
            
              cf.Save(filename);
              
             </code>
            </example>
        </member>
        <member name="M:CompoundFileStorage.CFStorage.ExistsStream(System.String)">
            <summary>
                Checks whether a child stream exists in the parent.
            </summary>
            <param name="streamName">Name of the stream to look for</param>
            <returns>A boolean value indicating whether the child stream exists.</returns>
            <example>
                <code>
             string filename = "report.xls";
            
             CompoundFile cf = new CompoundFile(filename);
             
             bool exists = ExistsStream("Workbook");
             
             if exists
             {
                 CFStream foundStream = cf.RootStorage.GetStream("Workbook");
             
                 byte[] temp = foundStream.GetData();
             }
            
             Assert.IsNotNull(temp);
            
             cf.Close();
             </code>
            </example>
        </member>
        <member name="M:CompoundFileStorage.CFStorage.GetStorage(System.String)">
            <summary>
                Get a named storage contained in the current one if existing.
            </summary>
            <param name="storageName">Name of the storage to look for</param>
            <returns>A storage reference if existing.</returns>
            <exception cref="T:CompoundFileStorage.Exceptions.CFItemNotFound">Raised if <see cref="!:storageName"/> is not found</exception>
        </member>
        <member name="M:CompoundFileStorage.CFStorage.AddStorage(System.String)">
            <summary>
                Create new child storage directory inside the current storage.
            </summary>
            <param name="storageName">The new storage name</param>
            <returns>Reference to the new <see cref="T:OpenMcdf.CFStorage">storage</see></returns>
            <exception cref="T:OpenMcdf.CFDuplicatedItemException">Raised when adding an item with the same name of an existing one</exception>
            <exception cref="T:OpenMcdf.CFDisposedException">Raised when adding a storage to a closed compound file</exception>
            <exception cref="T:OpenMcdf.CFException">Raised when adding a storage with null or empty name</exception>
            <example>
                <code>
             
              String filename = "A_NEW_COMPOUND_FILE_YOU_CAN_WRITE_TO.cfs";
            
              CompoundFile cf = new CompoundFile();
            
              CFStorage st = cf.RootStorage.AddStorage("MyStorage");
              CFStream sm = st.AddStream("MyStream");
              byte[] b = Helpers.GetBuffer(220, 0x0A);
              sm.SetData(b);
            
              cf.Save(filename);
              
             </code>
            </example>
        </member>
        <member name="M:CompoundFileStorage.CFStorage.ExistsStorage(System.String)">
            <summary>
                Checks if a child storage exists within the parent.
            </summary>
            <param name="storageName">Name of the storage to look for.</param>
            <returns>A boolean value indicating whether the child storage was found.</returns>
        </member>
        <member name="T:CompoundFileStorage.CFStream">
            <summary>
                OLE structured storage
                <see cref="T:DocumentServices.Modules.Extractors.OfficeExtractor.OLECompoundFileStorage.CFStream">stream</see>
                Object
                It is contained inside a Storage object in a file-directory relationship and indexed by its name.
            </summary>
        </member>
        <member name="T:CompoundFileStorage.Interfaces.ICFStream">
            <summary>
                The Stream interface
            </summary>
        </member>
        <member name="M:CompoundFileStorage.Interfaces.ICFStream.GetData">
            <summary>
                Get the data associated with the stream object.
            </summary>
            <example>
                <code>
                CompoundFile cf2 = new CompoundFile("AFileName.cfs");
                CFStream st = cf2.RootStorage.GetStream("MyStream");
                byte[] buffer = st.GetData();
            </code>
            </example>
            <returns>Array of byte containing stream data</returns>
            <exception cref="T:DocumentServices.Modules.Extractors.OfficeExtractor.OLECompoundFileStorage.CFDisposedException">
                Raised when the owner compound file has been closed.
            </exception>
        </member>
        <member name="M:CompoundFileStorage.Interfaces.ICFStream.GetData(System.Int64,System.Int32@)">
            <summary>
                Get <paramref name="count" /> bytes associated with the stream object, starting from
                a provided <paramref name="offset" />. When method returns, count will contain the
                effective count of bytes read.
            </summary>
            <example>
                <code>
            CompoundFile cf = new CompoundFile("AFileName.cfs");
            CFStream st = cf.RootStorage.GetStream("MyStream");
            int count = 8;
            // The stream is supposed to have a length greater than offset + count
            byte[] data = st.GetData(20, ref count);  
            cf.Close();
            </code>
            </example>
            <returns>Array of byte containing stream data</returns>
            <exception cref="T:DocumentServices.Modules.Extractors.OfficeExtractor.OLECompoundFileStorage.CFDisposedException">
                Raised when the owner compound file has been closed.
            </exception>
        </member>
        <member name="M:CompoundFileStorage.CFStream.SetData(System.Byte[])">
            <summary>
                Set the data associated with the stream object.
            </summary>
            <example>
                <code>
               byte[] b = new byte[]{0x0,0x1,0x2,0x3};
               CompoundFile cf = new CompoundFile();
               CFStream myStream = cf.RootStorage.AddStream("MyStream");
               myStream.SetData(b);
            </code>
            </example>
            <param name="data">Data bytes to write to this stream</param>
        </member>
        <member name="M:CompoundFileStorage.CFStream.GetData">
            <summary>
                Get the data associated with the stream object.
            </summary>
            <example>
                <code>
                CompoundFile cf2 = new CompoundFile("AFileName.cfs");
                CFStream st = cf2.RootStorage.GetStream("MyStream");
                byte[] buffer = st.GetData();
            </code>
            </example>
            <returns>Array of byte containing stream data</returns>
            <exception cref="T:DocumentServices.Modules.Extractors.OfficeExtractor.OLECompoundFileStorage.CFDisposedException">
                Raised when the owner compound file has been closed.
            </exception>
        </member>
        <member name="M:CompoundFileStorage.CFStream.GetData(System.Int64,System.Int32@)">
            <summary>
                Get <paramref name="count" /> bytes associated with the stream object, starting from
                a provided <paramref name="offset" />. When method returns, count will contain the
                effective count of bytes read.
            </summary>
            <example>
                <code>
            CompoundFile cf = new CompoundFile("AFileName.cfs");
            CFStream st = cf.RootStorage.GetStream("MyStream");
            int count = 8;
            // The stream is supposed to have a length greater than offset + count
            byte[] data = st.GetData(20, ref count);  
            cf.Close();
            </code>
            </example>
            <returns>Array of byte containing stream data</returns>
            <exception cref="T:DocumentServices.Modules.Extractors.OfficeExtractor.OLECompoundFileStorage.CFDisposedException">
                Raised when the owner compound file has been closed.
            </exception>
        </member>
        <member name="T:CompoundFileStorage.CFSVersion">
            <summary>
                Binary File Format Version. Sector size  is 512 byte for version 3,
                4096 for version 4
            </summary>
        </member>
        <member name="F:CompoundFileStorage.CFSVersion.Ver3">
            <summary>
                Compound file version 3 - The default and most common version available. Sector size 512 bytes, 2GB max file size.
            </summary>
        </member>
        <member name="F:CompoundFileStorage.CFSVersion.Ver4">
            <summary>
                Compound file version 4 - Sector size is 4096 bytes. Using this version could bring some compatibility problem with
                existing applications.
            </summary>
        </member>
        <member name="T:CompoundFileStorage.UpdateMode">
            <summary>
                Update mode of the compound file.
                Default is ReadOnly.
            </summary>
        </member>
        <member name="F:CompoundFileStorage.UpdateMode.ReadOnly">
            <summary>
                ReadOnly update mode prevents overwriting
                of the opened file.
                Data changes are allowed but they have to be
                persisted on a different file when required.
            </summary>
        </member>
        <member name="F:CompoundFileStorage.UpdateMode.Update">
            <summary>
                Update mode allows subsequent data changing operations
                to be persisted directly on the opened file or stream
                using the
                <see cref="M:CompoundFileStorage.CompoundFile.Commit">Commit</see>
                method when required. Warning: this option may cause existing data loss if misused.
            </summary>
        </member>
        <member name="T:CompoundFileStorage.CompoundFile">
            <summary>
                Standard Microsoft; Compound File implementation. It is also known as OLE/COM structured storage
                and contains a hierarchy of storage and stream objects providing  efficent storage of multiple
                kinds of documents in a single file. Version 3 and 4 of specifications are supported.
            </summary>
        </member>
        <member name="F:CompoundFileStorage.CompoundFile.FlushingQueueSize">
            <summary>
                Initial capacity of the flushing queue used
                to optimize commit writing operations
            </summary>
        </member>
        <member name="F:CompoundFileStorage.CompoundFile.FlushingBufferMaxSize">
            <summary>
                Maximum size of the flushing buffer used
                to optimize commit writing operations
            </summary>
        </member>
        <member name="F:CompoundFileStorage.CompoundFile.HeaderDIFATEntriesCount">
            <summary>
                Number of DIFAT entries in the header
            </summary>
        </member>
        <member name="F:CompoundFileStorage.CompoundFile.SizeOfSID">
            <summary>
                Sector ID Size (int)
            </summary>
        </member>
        <member name="F:CompoundFileStorage.CompoundFile._difatSectorFATEntriesCount">
            <summary>
                Number of FAT entries in a DIFAT Sector
            </summary>
        </member>
        <member name="F:CompoundFileStorage.CompoundFile._eraseFreeSectors">
            <summary>
                Flag for unallocated sector zeroing out.
            </summary>
        </member>
        <member name="F:CompoundFileStorage.CompoundFile._fatSectorEntriesCount">
            <summary>
                Sectors ID entries in a FAT Sector
            </summary>
        </member>
        <member name="F:CompoundFileStorage.CompoundFile._sectorRecycle">
            <summary>
                Flag for sector recycling.
            </summary>
        </member>
        <member name="F:CompoundFileStorage.CompoundFile._updateMode">
            <summary>
                True when update enabled
            </summary>
        </member>
        <member name="F:CompoundFileStorage.CompoundFile.SourceStream">
            <summary>
                Compound underlying stream. Null when new CF has been created.
            </summary>
        </member>
        <member name="F:CompoundFileStorage.CompoundFile._directoryEntries">
            <summary>
                Contains a list with all the directory entries
            </summary>
        </member>
        <member name="F:CompoundFileStorage.CompoundFile._header">
            <summary>
                CompoundFile header
            </summary>
        </member>
        <member name="F:CompoundFileStorage.CompoundFile._lockObject">
            <summary>
                Used for thread safe locking
            </summary>
        </member>
        <member name="F:CompoundFileStorage.CompoundFile._sectors">
            <summary>
                File sectors
            </summary>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.#ctor">
            <summary>
                Create a blank, version 3 compound file.
                Sector recycle is turned off to achieve the best reading/writing
                performance in most common scenarios.
            </summary>
            <example>
                <code>
             
                 byte[] b = new byte[10000];
                 for (int i = 0; i &lt; 10000; i++)
                 {
                     b[i % 120] = (byte)i;
                 }
            
                 CompoundFile cf = new CompoundFile();
                 CFStream myStream = cf.RootStorage.AddStream("MyStream");
            
                 Assert.IsNotNull(myStream);
                 myStream.SetData(b);
                 cf.Save("MyCompoundFile.cfs");
                 cf.Close();
                 
             </code>
            </example>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.#ctor(CompoundFileStorage.CFSVersion,System.Boolean)">
            <summary>
                Create a new, blank, compound file.
            </summary>
            <param name="cfsVersion">Use a specific Compound File Version to set 512 or 4096 bytes sectors</param>
            <param name="sectorRecycle">If true, recycle unused sectors</param>
            <example>
                <code>
             
                 byte[] b = new byte[10000];
                 for (int i = 0; i &lt; 10000; i++)
                 {
                     b[i % 120] = (byte)i;
                 }
            
                 CompoundFile cf = new CompoundFile(CFSVersion.Ver_4, true, true);
                 CFStream myStream = cf.RootStorage.AddStream("MyStream");
            
                 Assert.IsNotNull(myStream);
                 myStream.SetData(b);
                 cf.Save("MyCompoundFile.cfs");
                 cf.Close();
                 
             </code>
            </example>
            <remarks>
                Sector recycling reduces data writing performances but avoids space wasting in scenarios with frequently
                data manipulation of the same streams. The new compound file is open in Update mode.
            </remarks>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.#ctor(System.String,CompoundFileStorage.UpdateMode,System.Boolean,System.Boolean)">
            <summary>
                Load an existing compound file.
            </summary>
            <param name="fileName">Compound file to read from</param>
            <param name="sectorRecycle">If true, recycle unused sectors</param>
            <param name="updateMode">Select the update mode of the underlying data file</param>
            <param name="eraseFreeSectors">If true, overwrite with zeros unallocated sectors</param>
            <example>
                <code>
             string srcFilename = "data_YOU_CAN_CHANGE.xls";
             
             CompoundFile cf = new CompoundFile(srcFilename, UpdateMode.Update, true, true);
            
             Random r = new Random();
            
             byte[] buffer = GetBuffer(r.Next(3, 4095), 0x0A);
            
             cf.RootStorage.AddStream("MyStream").SetData(buffer);
             
             //This will persist data to the underlying media.
             cf.Commit();
             cf.Close();
            
             </code>
            </example>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.#ctor(System.IO.Stream,CompoundFileStorage.UpdateMode,System.Boolean,System.Boolean)">
            <summary>
                Load an existing compound file.
            </summary>
            <param name="stream">A stream containing a compound file to read</param>
            <param name="sectorRecycle">If true, recycle unused sectors</param>
            <param name="updateMode">Select the update mode of the underlying data file</param>
            <param name="eraseFreeSectors">If true, overwrite with zeros unallocated sectors</param>
            <example>
                <code>
             
             string filename = "reportREAD.xls";
               
             FileStream fs = new FileStream(filename, FileMode.Open);
             CompoundFile cf = new CompoundFile(fs, UpdateMode.ReadOnly, false, false);
             CFStream foundStream = cf.RootStorage.GetStream("Workbook");
            
             byte[] temp = foundStream.GetData();
            
             Assert.IsNotNull(temp);
            
             cf.Close();
            
             </code>
            </example>
            <exception cref="T:CompoundFileStorage.Exceptions.CFException">Raised when trying to open a non-seekable stream</exception>
            <exception cref="T:CompoundFileStorage.Exceptions.CFException">Raised stream is null</exception>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.#ctor(System.String,System.Boolean)">
            <summary>
                Load an existing compound file.
            </summary>
            <param name="fileName">Compound file to read from</param>
            <param name="readCorruptedFile">
                When set to <c>true</c> the code tries to read the file even when it is corrupted,
                otherwhise a <see cref="T:CompoundFileStorage.Exceptions.CFCorruptedFileException"/> exception is thrown
            </param>
            <example>
                <code>
             //A xls file should have a Workbook stream
             string filename = "report.xls";
            
             CompoundFile cf = new CompoundFile(filename);
             CFStream foundStream = cf.RootStorage.GetStream("Workbook");
            
             byte[] temp = foundStream.GetData();
            
             Assert.IsNotNull(temp);
            
             cf.Close();
             </code>
            </example>
            <remarks>
                File will be open in read-only mode: it has to be saved
                with a different filename. A wrapping implementation has to be provided
                in order to remove/substitute an existing file. Version will be
                automatically recognized from the file. Sector recycle is turned off
                to achieve the best reading/writing performance in most common scenarios.
            </remarks>
            <exception cref="T:CompoundFileStorage.Exceptions.CFCorruptedFileException">Raised when the file is corrupt and 
            <permission cref="!:readCorruptedFile"></permission> is set to <c>true</c></exception>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
                Load an existing compound file from a stream.
            </summary>
            <param name="stream">Streamed compound file</param>
            <param name="readCorruptedFile">
                When set to <c>true</c> the code tries to read the file even when it is corrupted,
                otherwhise a <see cref="T:CompoundFileStorage.Exceptions.CFCorruptedFileException"/> exception is thrown
            </param>
            <example>
                <code>
             
             string filename = "reportREAD.xls";
               
             FileStream fs = new FileStream(filename, FileMode.Open);
             CompoundFile cf = new CompoundFile(fs);
             CFStream foundStream = cf.RootStorage.GetStream("Workbook");
            
             byte[] temp = foundStream.GetData();
            
             Assert.IsNotNull(temp);
            
             cf.Close();
            
             </code>
            </example>
            <exception cref="T:CompoundFileStorage.Exceptions.CFException">Raised when trying to open a non-seekable stream</exception>
            <exception cref="T:CompoundFileStorage.Exceptions.CFException">Raised stream is null</exception>
            <exception cref="T:CompoundFileStorage.Exceptions.CFCorruptedFileException">Raised when the file is corrupt and 
            <permission cref="!:readCorruptedFile"></permission> is set to <c>true</c></exception>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.Commit">
            <summary>
                Commit data changes since the previously commit operation
                to the underlying supporting stream or file on the disk.
            </summary>
            <remarks>
                This method can be used
                only if the supporting stream has been opened in
                <see cref="T:CompoundFileStorage.UpdateMode">Update mode</see>.
            </remarks>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.Commit(System.Boolean)">
            <summary>
                Commit data changes since the previously commit operation
                to the underlying supporting stream or file on the disk.
            </summary>
            <param name="releaseMemory">
                If true, release loaded sectors to limit memory usage but reduces following read operations
                performance
            </param>
            <remarks>
                This method can be used only if
                the supporting stream has been opened in
                <see cref="T:CompoundFileStorage.UpdateMode">Update mode</see>.
            </remarks>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.Load(System.IO.Stream)">
            <summary>
                Load compound file from an existing stream.
            </summary>
            <param name="stream">Stream to load compound file from</param>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.GetSectorSize">
            <summary>
                Returns the size of standard sectors switching on CFS version (3 or 4)
            </summary>
            <returns>Standard sector size</returns>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.LoadFile(System.String)">
            <summary>
                Loads a compound file from a file
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.LoadStream(System.IO.Stream)">
            <summary>
                Loads a compound file from a <see cref="!:stream"/>
            </summary>
            <param name="stream"></param>
            <exception cref="T:CompoundFileStorage.Exceptions.CFException">Raised when the stream is null or non-seekable</exception>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.Save(System.String)">
            <summary>
                Saves the in-memory image of Compound File to a file.
            </summary>
            <param name="fileName">File name to write the compound file to</param>
            <exception cref="T:CompoundFileStorage.Exceptions.CFException">Raised when file is closed</exception>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.Save(System.IO.Stream)">
            <summary>
                Saves the in-memory image of Compound File to a stream.
            </summary>
            <remarks>
                Destination Stream must be seekable.
            </remarks>
            <param name="stream">The stream to save compound File to</param>
            <exception cref="T:CompoundFileStorage.Exceptions.CFException">Raised if destination stream is not seekable</exception>
            <exception cref="T:CompoundFileStorage.Exceptions.CFDisposedException">Raised if Compound File Storage has been already disposed</exception>
            <example>
                <code>
                MemoryStream ms = new MemoryStream(size);
            
                CompoundFile cf = new CompoundFile();
                CFStorage st = cf.RootStorage.AddStorage("MyStorage");
                CFStream sm = st.AddStream("MyStream");
            
                byte[] b = new byte[]{0x00,0x01,0x02,0x03};
            
                sm.SetData(b);
                cf.Save(ms);
                cf.Close();
             </code>
            </example>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.Close">
            <summary>
                Close the Compound File object <see cref="T:CompoundFileStorage.CompoundFile">CompoundFile</see> and
                free all associated resources (e.g. open file handle and allocated memory).
                <remarks>
                    When the <see cref="M:CompoundFileStorage.CompoundFile.Close">Close</see> method is called,
                    all the associated stream and storage objects are invalidated:
                    any operation invoked on them will produce a
                    <see cref="T:CompoundFileStorage.Exceptions.CFDisposedException">CFDisposedException</see>.
                </remarks>
            </summary>
            <example>
                <code>
                const string FILENAME = "CompoundFile.cfs";
                CompoundFile cf = new CompoundFile(FILENAME);
            
                CFStorage st = cf.RootStorage.GetStorage("MyStorage");
                cf.Close();
            
                try
                {
                    byte[] temp = st.GetStream("MyStream").GetData();
                    
                    // The following line will fail because back-end object has been closed
                    Assert.Fail("Stream without media");
                }
                catch (Exception ex)
                {
                    Assert.IsTrue(ex is CFDisposedException);
                }
             </code>
            </example>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.SetMiniSectorChain(System.Collections.Generic.IList{CompoundFileStorage.Sector})">
            <summary>
                Allocate space, setup sectors id and refresh header
                for the new or updated mini sector chain.
            </summary>
            <param name="sectorChain">The new MINI sector chain</param>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.SetNormalSectorChain(System.Collections.Generic.List{CompoundFileStorage.Sector})">
            <summary>
                Allocate space, setup sectors id and refresh header
                for the new or updated sector chain.
            </summary>
            <param name="sectorChain">The new or updated generic sector chain</param>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.CheckForLockSector">
            <summary>
                Check for transaction lock sector addition and mark it in the FAT.
            </summary>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.SetFATSectorChain(System.Collections.Generic.IList{CompoundFileStorage.Sector})">
            <summary>
                Allocate space, setup sectors id and refresh header
                for the new or updated FAT sector chain.
            </summary>
            <param name="sectorChain">The new or updated generic sector chain</param>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.SetDIFATSectorChain(System.Collections.Generic.List{CompoundFileStorage.Sector})">
            <summary>
                Setup the DIFAT sector chain
            </summary>
            <param name="faTsectorChain">A FAT sector chain</param>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.GetDifatSectorChain">
            <summary>
                Get the DIFAT Sector chain
            </summary>
            <returns>A list of DIFAT sectors</returns>
            <exception cref="T:CompoundFileStorage.Exceptions.CFCorruptedFileException">Raised when DIFAT sectors count is mismatched</exception>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.GetFatSectorChain">
            <summary>
                Get the FAT sector chain
            </summary>
            <returns>List of FAT sectors</returns>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.GetNormalSectorChain(System.Int32)">
            <summary>
                Get a standard sector chain
            </summary>
            <param name="secId">First SecID of the required chain</param>
            <returns>A list of sectors</returns>
            <exception cref="T:CompoundFileStorage.Exceptions.CFCorruptedFileException">Raised when the file is corrupt</exception>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.GetMiniSectorChain(System.Int32)">
            <summary>
                Get a mini sector chain
            </summary>
            <param name="sectorId">First sector id of the required chain</param>
            <returns>A list of mini sectors (64 bytes)</returns>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.GetSectorChain(System.Int32,CompoundFileStorage.SectorType)">
            <summary>
                Get a sector chain from a compound file given the first sector ID
                and the required sector type.
            </summary>
            <param name="sectorId">First chain sector's id </param>
            <param name="chainType">Type of Sectors in the required chain (mini sectors, normal sectors or FAT)</param>
            <returns>A list of Sectors as the result of their concatenation</returns>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.InsertNewDirectoryEntry(CompoundFileStorage.Interfaces.IDirectoryEntry)">
            <summary>
                Inserts a new <see cref="!:directoryEntry"/>
            </summary>
            <param name="directoryEntry"></param>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.ResetDirectoryEntry(System.Int32)">
            <summary>
                Reset a directory entry setting it to StgInvalid in the Directory.
            </summary>
            <param name="sid">Sid of the directory to invalidate</param>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.GetChildrenTree(System.Int32)">
            <summary>
                Returns the children tree for the given <see cref="!:sid"/>
            </summary>
            <param name="sid"></param>
            <returns></returns>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.LoadSiblings(System.Collections.Generic.ICollection{CompoundFileStorage.CFItem},CompoundFileStorage.Interfaces.IDirectoryEntry)">
            <summary>
                Doubling methods allows iterative behavior while avoiding to insert duplicate items
            </summary>
            <param name="binarySearchTree"></param>
            <param name="directoryEntry"></param>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.ValidateSibling(System.Int32)">
            <summary>
                Validates all the siblings
            </summary>
            <param name="sid"></param>
            <returns></returns>
            <exception cref="T:CompoundFileStorage.Exceptions.CFCorruptedFileException">Raised when there is an invalid reference of storage type</exception>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.LoadDirectories">
            <summary>
                Load directory entries from compound file. Header and FAT MUST be already loaded.
            </summary>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.RemoveDirectoryEntry(System.Int32)">
            <summary>
                Removes an directory entry
            </summary>
            <param name="sid"></param>
            <exception cref="T:CompoundFileStorage.Exceptions.CFException">Raised when the <see cref="!:sid"/> is invalid</exception>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.CommitDirectory">
            <summary>
                Commit directory entries change on the Current Source stream
            </summary>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.RefreshSIDs(CompoundFileStorage.BinaryTree.BinaryTreeNode{CompoundFileStorage.CFItem})">
            <summary>
                Refreshes all SID's for the give node
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.FindFreeSectors(CompoundFileStorage.SectorType)">
            <summary>
                Scan FAT o miniFAT for free sectors to reuse.
            </summary>
            <param name="sType">Type of sector to look for</param>
            <returns>A stack of available sectors or minisectors already allocated</returns>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.SetData(CompoundFileStorage.CFItem,System.Byte[])">
            <summary>
                Sets the data for the current stream
            </summary>
            <param name="cfItem"></param>
            <param name="buffer"></param>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.SetStreamData(CompoundFileStorage.CFItem,System.Byte[])">
            <summary>
                Sets the data for the current stream
            </summary>
            <param name="cfItem"></param>
            <param name="buffer"></param>
            <exception cref="T:CompoundFileStorage.Exceptions.CFException">Raised when <see cref="!:buffer"/> is null</exception>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.GetData(CompoundFileStorage.CFStream,System.Int64,System.Int32@)">
            <summary>
                Gets data from the <see cref="!:cFStream"/>
            </summary>
            <param name="cFStream"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
            <exception cref="T:CompoundFileStorage.Exceptions.CFDisposedException">Raised when the file is closed</exception>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.GetData(CompoundFileStorage.CFStream)">
            <summary>
                Gets data from the <see cref="!:cFStream"/>
            </summary>
            <param name="cFStream"></param>
            <returns></returns>
            <exception cref="T:CompoundFileStorage.Exceptions.CFDisposedException">Raised when the file is closed</exception>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.Dispose(System.Boolean)">
            <summary>
                When called from user code, release all resources, otherwise, in the case runtime called it,
                only unmanagd resources are released.
            </summary>
            <param name="disposing">If true, method has been called from User code, if false it's been called from .net runtime</param>
        </member>
        <member name="M:CompoundFileStorage.CompoundFile.GetAllNamedEntries(System.String,System.Nullable{System.Int32})">
            <summary>
                Get a list of all entries which start with the given <see cref="!:entryName"/>
            </summary>
            <param name="entryName">Name of entries to retrive</param>
            <param name="parentSibling">
                The parent id from the node where you want to find the named entries,
                use null if you want to search in all nodes
            </param>
            <returns>A list of name-matching entries</returns>
            <remarks>
                This function is aimed to speed up entity lookup in
                flat-structure files (only one or little more known entries)
                without the performance penalty related to entities hierarchy constraints.
                There is no implied hierarchy in the returned list.
            </remarks>
        </member>
        <member name="P:CompoundFileStorage.CompoundFile.RootStorage">
            <summary>
                The entry point object that represents the
                root of the structures tree to get or set storage or
                stream data.
            </summary>
            <example>
                <code>
             
                //Create a compound file
                string FILENAME = "MyFileName.cfs";
                CompoundFile ncf = new CompoundFile();
            
                CFStorage l1 = ncf.RootStorage.AddStorage("Storage Level 1");
            
                l1.AddStream("l1ns1");
                l1.AddStream("l1ns2");
                l1.AddStream("l1ns3");
                CFStorage l2 = l1.AddStorage("Storage Level 2");
                l2.AddStream("l2ns1");
                l2.AddStream("l2ns2");
            
                ncf.Save(FILENAME);
                ncf.Close();
             </code>
            </example>
        </member>
        <member name="P:CompoundFileStorage.CompoundFile.RootEntry">
            <summary>
                The root entry of all the <see cref="T:System.IO.Directory"/> entries
            </summary>
        </member>
        <member name="P:CompoundFileStorage.CompoundFile.IsClosed">
            <summary>
                True when the compound file is closed
            </summary>
        </member>
        <member name="P:CompoundFileStorage.CompoundFile.FileName">
            <summary>
                The name of the compound file, null when the compound file is opened from a stream
            </summary>
        </member>
        <member name="P:CompoundFileStorage.CompoundFile.ReadCorruptedFile">
            <summary>
                When set to <c>true</c> the code tries to read the file even when it is corrupted,
                otherwhise a <see cref="T:CompoundFileStorage.Exceptions.CFCorruptedFileException"/> exception is thrown
            </summary>
        </member>
        <member name="P:CompoundFileStorage.CompoundFile.HasSourceStream">
            <summary>
                Return true if this compound file has been loaded from an existing file or stream
            </summary>
        </member>
        <member name="P:CompoundFileStorage.CompoundFile.Version">
            <summary>
                Returns the version number of the compound file storage
            </summary>
        </member>
        <member name="T:CompoundFileStorage.Interfaces.IDirectoryEntry">
            <summary>
                The directory entry interface
            </summary>
        </member>
        <member name="M:CompoundFileStorage.DirectoryEntry.GetEntryName">
            <summary>
                Gets the name of the directory entry
            </summary>
            <returns></returns>
        </member>
        <member name="M:CompoundFileStorage.DirectoryEntry.SetEntryName(System.String)">
            <summary>
                Sets the name of the directory entry
            </summary>
            <param name="entryName"></param>
            <exception cref="T:CompoundFileStorage.Exceptions.CFException">Raised when an invalid character is used or the length is longer then 31</exception>
        </member>
        <member name="M:CompoundFileStorage.DirectoryEntry.CompareTo(System.Object)">
            <summary>
                Compares the object to the current IDirectory entry
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:CompoundFileStorage.DirectoryEntry.fnv_hash(System.Collections.Generic.IList{System.Byte})">
            <summary>
                FNV hash, short for Fowler/Noll/Vo
            </summary>
            <param name="buffer"></param>
            <returns>(not warranted) unique hash for byte array</returns>
        </member>
        <member name="M:CompoundFileStorage.DirectoryEntry.Write(System.IO.Stream)">
            <summary>
                Writes to the <see cref="!:stream"/>
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:CompoundFileStorage.DirectoryEntry.Read(System.IO.Stream)">
            <summary>
                Reads from the <see cref="!:stream"/>
            </summary>
            <param name="stream"></param>
        </member>
        <member name="P:CompoundFileStorage.DirectoryEntry.Name">
            <summary>
                The name of the directory entry
            </summary>
        </member>
        <member name="T:CompoundFileStorage.Exceptions.CFCorruptedFileException">
            <summary>
                Raised when trying to load a Compound File with an invalid, corrupted or mismatched fields (4.1 - specifications).
            </summary>
            <remarks>
                This exception is NOT raised when Compound file has been opened with the NO_VALIDATION_EXCEPTION option.
            </remarks>
        </member>
        <member name="T:CompoundFileStorage.Exceptions.CFException">
            <summary>
                The base exception for all the exceptions that are raised in the CompoundFileStorage namespace
            </summary>
        </member>
        <member name="T:CompoundFileStorage.Exceptions.CFDisposedException">
            <summary>
                Raised when a data setter/getter method is invoked on a stream or storage object after the
                disposal of the owner compound file object.
            </summary>
        </member>
        <member name="T:CompoundFileStorage.Exceptions.CFDuplicatedItemException">
            <summary>
                Raised when trying to add a duplicated CFItem.
            </summary>
            <remarks>
                Items are compared by name as indicated by specs. Two items with the same name CANNOT be added within
                the same storage or sub-storage.
            </remarks>
        </member>
        <member name="T:CompoundFileStorage.Exceptions.CFFileFormatException">
            <summary>
                Raised when opening a file with invalid header or not supported COM/OLE Structured storage version.
            </summary>
        </member>
        <member name="T:CompoundFileStorage.Exceptions.CFFormatException">
            <summary>
                Raised when a file with an invalid header or a NON supported COM/OLE structured storage version is opened.
            </summary>
        </member>
        <member name="T:CompoundFileStorage.Exceptions.CFInvalidOperation">
            <summary>
                Raised when a method call is invalid for the current object state.
            </summary>
        </member>
        <member name="T:CompoundFileStorage.Exceptions.CFItemNotFound">
            <summary>
                Raised when a named stream or a storage object is not found in a parent storage.
            </summary>
        </member>
        <member name="T:CompoundFileStorage.Header">
            <summary>
                This class contains the header of an OLE structured storage file
            </summary>
        </member>
        <member name="F:CompoundFileStorage.Header._oleCFSSignature">
            <summary>
                Structured Storage signature
            </summary>
        </member>
        <member name="M:CompoundFileStorage.Header.Read(System.IO.Stream)">
            <summary>
                Reads from the <see cref="!:stream"/>
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:CompoundFileStorage.Header.Write(System.IO.Stream)">
            <summary>
                Writes to the <see cref="!:stream"/>
            </summary>
            <param name="stream"></param>
        </member>
        <member name="P:CompoundFileStorage.Header.HeaderSignature">
            <summary>
                Compound document file identifier: D0H CFH 11H E0H A1H B1H 1AH E1H
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Header.CLSID">
            <summary>
                Unique identifier (UID) of this file (not of interest in the following, may be all 0)
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Header.MinorVersion">
            <summary>
                Revision number of the file format (most used is 003EH)
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Header.MajorVersion">
            <summary>
                Version number of the file format (most used is 0003H)
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Header.ByteOrder">
            <summary>
                Byte order identifier (4.2): FEH FFH = Little-Endian FFH FEH = Big-Endian
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Header.SectorShift">
            <summary>
                Size of a sector in the compound document file (3.1) in power-of-two (ssz), real sector
                size is sec_size = 2ssz bytes (minimum value is 7 which means 128 bytes, most used
                value is 9 which means 512 bytes)
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Header.MiniSectorShift">
            <summary>
                Size of a short-sector in the short-stream container stream (6.1) in power-of-two (sssz),
                real short-sector size is short_sec_size = 2sssz bytes (maximum value is sector size
                ssz, see above, most used value is 6 which means 64 bytes)
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Header.UnUsed">
            <summary>
                Not used
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Header.DirectorySectorsNumber">
            <summary>
                Total number of sectors used Directory (5.2)
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Header.FATSectorsNumber">
            <summary>
                Total number of sectors used for the sector allocation table (5.2)
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Header.FirstDirectorySectorId">
            <summary>
                SecID of first sector of the directory stream (7)
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Header.UnUsed2">
            <summary>
                Not used
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Header.MinSizeStandardStream">
            <summary>
                Minimum size of a standard stream (in bytes, minimum allowed and most used size is 4096
                bytes), streams with an actual size smaller than (and not equal to) this value are stored as
                short-streams (6)
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Header.FirstMiniFATSectorId">
            <summary>
                This integer field contains the starting sector number for the mini FAT
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Header.MiniFATSectorsNumber">
            <summary>
                Total number of sectors used for the short-sector allocation table (6.2)
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Header.FirstDIFATSectorId">
            <summary>
                SecID of first sector of the master sector allocation table (5.1), or 2 (End Of Chain
                SecID, 3.1) if no additional sectors used
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Header.DIFATSectorsNumber">
            <summary>
                Total number of sectors used for the master sector allocation table (5.1)
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Header.DIFAT">
            <summary>
                First part of the master sector allocation table (5.1) containing 109 SecIDs
            </summary>
        </member>
        <member name="T:CompoundFileStorage.Interfaces.ICompoundFile">
            <summary>
                The CompoundFile interface
            </summary>
        </member>
        <member name="M:CompoundFileStorage.Interfaces.ICompoundFile.Close">
            <summary>
                Close the Compound File object <see cref="T:OpenMcdf.CompoundFile">CompoundFile</see> and
                free all associated resources (e.g. open file handle and allocated memory).
                <remarks>
                    When the <see cref="T:OpenMcdf.CompoundFile.Close()">Close</see> method is called,
                    all the associated stream and storage objects are invalidated:
                    any operation invoked on them will produce a
                    <see cref="T:OpenMcdf.CFDisposedException">CFDisposedException</see>.
                </remarks>
            </summary>
        </member>
        <member name="M:CompoundFileStorage.Interfaces.ICompoundFile.GetAllNamedEntries(System.String)">
            <summary>
                Get a list of all entries with a given name contained in the document.
            </summary>
            <param name="entryName">Name of entries to retrive</param>
            <returns>A list of name-matching entries</returns>
            <remarks>
                This function is aimed to speed up entity lookup in
                flat-structure files (only one or little more known entries)
                without the performance penalty related to entities hierarchy constraints.
                There is no implied hierarchy in the returned list.
            </remarks>
        </member>
        <member name="P:CompoundFileStorage.Interfaces.ICompoundFile.HasSourceStream">
            <summary>
                Return true if this compound file has been loaded from an existing file or stream
            </summary>
        </member>
        <member name="P:CompoundFileStorage.Interfaces.ICompoundFile.RootStorage">
            <summary>
                The entry point object that represents the
                root of the structures tree to get stream data.
            </summary>
        </member>
        <member name="M:CompoundFileStorage.Sector.Dispose(System.Boolean)">
            <summary>
                When called from user code, release all resources, otherwise, in the case runtime called it,
                only unmanagd resources are released.
            </summary>
            <param name="disposing">If true, method has been called from User code, if false it's been called from .net runtime</param>
        </member>
        <member name="T:CompoundFileStorage.SectorCollection">
            <summary>
                Ad-hoc Heap Friendly sector collection to avoid using large array that may create some problem to GC collection
                (see http://www.simple-talk.com/dotnet/.net-framework/the-dangers-of-the-large-object-heap/ )
            </summary>
        </member>
        <member name="T:CompoundFileStorage.StreamRW">
            <summary>
                Used to read from the stream
            </summary>
        </member>
        <member name="T:CompoundFileStorage.StreamView">
            <summary>
                Stream decorator for a Sector or miniSector chain
            </summary>
        </member>
        <member name="F:CompoundFileStorage.StreamView._buf">
            <summary>
                The <see cref="F:CompoundFileStorage.StreamView._stream"/> buffer
            </summary>
        </member>
        <member name="F:CompoundFileStorage.StreamView._sectorChain">
            <summary>
                The sector chain
            </summary>
        </member>
        <member name="F:CompoundFileStorage.StreamView._sectorSize">
            <summary>
                The size of a sector in the <see cref="F:CompoundFileStorage.StreamView._stream"/>
            </summary>
        </member>
        <member name="F:CompoundFileStorage.StreamView._stream">
            <summary>
                The stream to view
            </summary>
        </member>
        <member name="F:CompoundFileStorage.StreamView._length">
            <summary>
                The length of the <see cref="F:CompoundFileStorage.StreamView._stream"/>
            </summary>
        </member>
        <member name="F:CompoundFileStorage.StreamView._position">
            <summary>
                The current position in the stresm
            </summary>
        </member>
        <member name="M:CompoundFileStorage.StreamView.#ctor(System.Collections.Generic.List{CompoundFileStorage.Sector},System.Int32,System.IO.Stream)">
            <summary>
                Creates this object
            </summary>
            <param name="sectorChain"></param>
            <param name="sectorSize"></param>
            <param name="stream"></param>
            <exception cref="T:CompoundFileStorage.Exceptions.CFException">
                Raised when <see cref="!:sectorChain"/> is null or <see cref="!:sectorSize"/> is zero or
                smaller
            </exception>
        </member>
        <member name="M:CompoundFileStorage.StreamView.Flush">
            <summary>
                Flushes the stream... NOT IMPLEMENTED
            </summary>
        </member>
        <member name="M:CompoundFileStorage.StreamView.ReadInt32">
            <summary>
                Reads a 32 bit integer from the <see cref="F:CompoundFileStorage.StreamView._stream"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:CompoundFileStorage.StreamView.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
                Reads from the <see cref="F:CompoundFileStorage.StreamView._stream"/>
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:CompoundFileStorage.StreamView.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
                Seeks a new position in the <see cref="F:CompoundFileStorage.StreamView._stream"/> from the <see cref="!:origin"/>
            </summary>
            <param name="offset"></param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="M:CompoundFileStorage.StreamView.AdjustLength(System.Int64)">
            <summary>
                Adjusts the length of the <see cref="F:CompoundFileStorage.StreamView._stream"/>
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:CompoundFileStorage.StreamView.AdjustLength(System.Int64,System.Collections.Generic.Queue{CompoundFileStorage.Sector})">
            <summary>
                Adjusts the length of the <see cref="F:CompoundFileStorage.StreamView._stream"/>
            </summary>
            <param name="value"></param>
            <param name="availableSectors"></param>
        </member>
        <member name="M:CompoundFileStorage.StreamView.SetLength(System.Int64)">
            <summary>
                Adjusts the length of the <see cref="F:CompoundFileStorage.StreamView._stream"/>
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:CompoundFileStorage.StreamView.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
                Writes the <see cref="!:buffer"/> to the <see cref="F:CompoundFileStorage.StreamView._stream"/> on the <see cref="!:offset"/>
            </summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
    </members>
</doc>
