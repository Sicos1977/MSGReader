<?xml version="1.0"?>
<doc>
    <assembly>
        <name>OpenMcdf</name>
    </assembly>
    <members>
        <member name="T:OpenMcdf.CFException">
            <summary>
            OpenMCDF base exception.
            </summary>
        </member>
        <member name="T:OpenMcdf.CFDisposedException">
            <summary>
            Raised when a data setter/getter method is invoked
            on a stream or storage object after the disposal of the owner
            compound file object.
            </summary>
        </member>
        <member name="T:OpenMcdf.CFFileFormatException">
            <summary>
            Raised when opening a file with invalid header
            or not supported COM/OLE Structured storage version.
            </summary>
        </member>
        <member name="T:OpenMcdf.CFItemNotFound">
            <summary>
            Raised when a named stream or a storage object
            are not found in a parent storage.
            </summary>
        </member>
        <member name="T:OpenMcdf.CFInvalidOperation">
            <summary>
            Raised when a method call is invalid for the current object state
            </summary>
        </member>
        <member name="T:OpenMcdf.CFDuplicatedItemException">
            <summary>
            Raised when trying to add a duplicated CFItem
            </summary>
            <remarks>
            Items are compared by name as indicated by specs.
            Two items with the same name CANNOT be added within 
            the same storage or sub-storage. 
            </remarks>
        </member>
        <member name="T:OpenMcdf.CFCorruptedFileException">
            <summary>
            Raised when trying to load a Compound File with invalid, corrupted or mismatched fields (4.1 - specifications) 
            </summary>
            <remarks>
            This exception is NOT raised when Compound file has been opened with NO_VALIDATION_EXCEPTION option.
            </remarks>
        </member>
        <member name="T:OpenMcdf.CFItem">
             <summary>
             Abstract base class for Structured Storage entities.
             </summary>
             <example>
             <code>
             
             const String STORAGE_NAME = "report.xls";
             CompoundFile cf = new CompoundFile(STORAGE_NAME);
            
             FileStream output = new FileStream("LogEntries.txt", FileMode.Create);
             TextWriter tw = new StreamWriter(output);
            
             // CFItem represents both storage and stream items
             VisitedEntryAction va = delegate(CFItem item)
             {
                  tw.WriteLine(item.Name);
             };
            
             cf.RootStorage.VisitEntries(va, true);
            
             tw.Close();
             
             </code>
             </example>
        </member>
        <member name="P:OpenMcdf.CFItem.Name">
            <summary>
            Get entity name
            </summary>
        </member>
        <member name="P:OpenMcdf.CFItem.Size">
            <summary>
            Size in bytes of the item. It has a valid value 
            only if entity is a stream, otherwise it is setted to zero.
            </summary>
        </member>
        <member name="P:OpenMcdf.CFItem.IsStorage">
            <summary>
            Return true if item is Storage
            </summary>
            <remarks>
            This check doesn't use reflection or runtime type information
            and doesn't suffer related performance penalties.
            </remarks>
        </member>
        <member name="P:OpenMcdf.CFItem.IsStream">
            <summary>
            Return true if item is a Stream
            </summary>
            <remarks>
            This check doesn't use reflection or runtime type information
            and doesn't suffer related performance penalties.
            </remarks>
        </member>
        <member name="P:OpenMcdf.CFItem.IsRoot">
            <summary>
            Return true if item is the Root Storage
            </summary>
            <remarks>
            This check doesn't use reflection or runtime type information
            and doesn't suffer related performance penalties.
            </remarks>
        </member>
        <member name="P:OpenMcdf.CFItem.CreationDate">
            <summary>
            Get/Set the Creation Date of the current item
            </summary>
        </member>
        <member name="P:OpenMcdf.CFItem.ModifyDate">
            <summary>
            Get/Set the Modify Date of the current item
            </summary>
        </member>
        <member name="P:OpenMcdf.CFItem.CLSID">
            <summary>
            Get/Set Object class Guid for Root and Storage entries.
            </summary>
        </member>
        <member name="T:OpenMcdf.VisitedEntryAction">
             <summary>
             Action to apply to  visited items in the OLE structured storage
             </summary>
             <param name="item">Currently visited <see cref="T:OpenMcdf.CFItem">item</see></param>
             <example>
             <code>
             
             //We assume that xls file should be a valid OLE compound file
             const String STORAGE_NAME = "report.xls";
             CompoundFile cf = new CompoundFile(STORAGE_NAME);
            
             FileStream output = new FileStream("LogEntries.txt", FileMode.Create);
             TextWriter tw = new StreamWriter(output);
            
             VisitedEntryAction va = delegate(CFItem item)
             {
                 tw.WriteLine(item.Name);
             };
            
             cf.RootStorage.VisitEntries(va, true);
            
             tw.Close();
            
             </code>
             </example>
        </member>
        <member name="T:OpenMcdf.CFStorage">
            <summary>
            Storage entity that acts like a logic container for streams
            or substorages in a compound file.
            </summary>
        </member>
        <member name="M:OpenMcdf.CFStorage.#ctor(OpenMcdf.CompoundFile,OpenMcdf.IDirectoryEntry)">
            <summary>
            Create a CFStorage using an existing directory (previously loaded).
            </summary>
            <param name="compFile">The Storage Owner - CompoundFile</param>
            <param name="dirEntry">An existing Directory Entry</param>
        </member>
        <member name="M:OpenMcdf.CFStorage.AddStream(System.String)">
             <summary>
             Create a new child stream inside the current <see cref="T:OpenMcdf.CFStorage">storage</see>
             </summary>
             <param name="streamName">The new stream name</param>
             <returns>The new <see cref="T:OpenMcdf.CFStream">stream</see> reference</returns>
             <exception cref="T:OpenMcdf.CFDuplicatedItemException">Raised when adding an item with the same name of an existing one</exception>
             <exception cref="T:OpenMcdf.CFDisposedException">Raised when adding a stream to a closed compound file</exception>
             <exception cref="T:OpenMcdf.CFException">Raised when adding a stream with null or empty name</exception>
             <example>
             <code>
             
              String filename = "A_NEW_COMPOUND_FILE_YOU_CAN_WRITE_TO.cfs";
            
              CompoundFile cf = new CompoundFile();
            
              CFStorage st = cf.RootStorage.AddStorage("MyStorage");
              CFStream sm = st.AddStream("MyStream");
              byte[] b = Helpers.GetBuffer(220, 0x0A);
              sm.SetData(b);
            
              cf.Save(filename);
              
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CFStorage.GetStream(System.String)">
             <summary>
             Get a named <see cref="T:OpenMcdf.CFStream">stream</see> contained in the current storage if existing.
             </summary>
             <param name="streamName">Name of the stream to look for</param>
             <returns>A stream reference if existing</returns>
             <exception cref="T:OpenMcdf.CFDisposedException">Raised if trying to delete item from a closed compound file</exception>
             <exception cref="T:OpenMcdf.CFItemNotFound">Raised if item to delete is not found</exception>
             <example>
             <code>
             String filename = "report.xls";
            
             CompoundFile cf = new CompoundFile(filename);
             CFStream foundStream = cf.RootStorage.GetStream("Workbook");
            
             byte[] temp = foundStream.GetData();
            
             Assert.IsNotNull(temp);
            
             cf.Close();
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CFStorage.TryGetStream(System.String)">
             <summary>
             Get a named <see cref="T:OpenMcdf.CFStream">stream</see> contained in the current storage if existing.
             </summary>
             <param name="streamName">Name of the stream to look for</param>
             <returns>A stream reference if found, else null</returns>
             <exception cref="T:OpenMcdf.CFDisposedException">Raised if trying to delete item from a closed compound file</exception>
             <example>
             <code>
             String filename = "report.xls";
            
             CompoundFile cf = new CompoundFile(filename);
             CFStream foundStream = cf.RootStorage.TryGetStream("Workbook");
            
             byte[] temp = foundStream.GetData();
            
             Assert.IsNotNull(temp);
            
             cf.Close();
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CFStorage.GetStorage(System.String)">
             <summary>
             Get a named storage contained in the current one if existing.
             </summary>
             <param name="storageName">Name of the storage to look for</param>
             <returns>A storage reference if existing.</returns>
             <exception cref="T:OpenMcdf.CFDisposedException">Raised if trying to delete item from a closed compound file</exception>
             <exception cref="T:OpenMcdf.CFItemNotFound">Raised if item to delete is not found</exception>
             <example>
             <code>
             
             String FILENAME = "MultipleStorage2.cfs";
             CompoundFile cf = new CompoundFile(FILENAME, UpdateMode.ReadOnly, false, false);
            
             CFStorage st = cf.RootStorage.GetStorage("MyStorage");
            
             Assert.IsNotNull(st);
             cf.Close();
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CFStorage.TryGetStorage(System.String)">
             <summary>
             Get a named storage contained in the current one if existing.
             </summary>
             <param name="storageName">Name of the storage to look for</param>
             <returns>A storage reference if found else null</returns>
             <exception cref="T:OpenMcdf.CFDisposedException">Raised if trying to delete item from a closed compound file</exception>
             <example>
             <code>
             
             String FILENAME = "MultipleStorage2.cfs";
             CompoundFile cf = new CompoundFile(FILENAME, UpdateMode.ReadOnly, false, false);
            
             CFStorage st = cf.RootStorage.TryGetStorage("MyStorage");
            
             Assert.IsNotNull(st);
             cf.Close();
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CFStorage.AddStorage(System.String)">
             <summary>
             Create new child storage directory inside the current storage.
             </summary>
             <param name="storageName">The new storage name</param>
             <returns>Reference to the new <see cref="T:OpenMcdf.CFStorage">storage</see></returns>
             <exception cref="T:OpenMcdf.CFDuplicatedItemException">Raised when adding an item with the same name of an existing one</exception>
             <exception cref="T:OpenMcdf.CFDisposedException">Raised when adding a storage to a closed compound file</exception>
             <exception cref="T:OpenMcdf.CFException">Raised when adding a storage with null or empty name</exception>
             <example>
             <code>
             
              String filename = "A_NEW_COMPOUND_FILE_YOU_CAN_WRITE_TO.cfs";
            
              CompoundFile cf = new CompoundFile();
            
              CFStorage st = cf.RootStorage.AddStorage("MyStorage");
              CFStream sm = st.AddStream("MyStream");
              byte[] b = Helpers.GetBuffer(220, 0x0A);
              sm.SetData(b);
            
              cf.Save(filename);
              
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CFStorage.VisitEntries(System.Action{OpenMcdf.CFItem},System.Boolean)">
             <summary>
             Visit all entities contained in the storage applying a user provided action
             </summary>
             <exception cref="T:OpenMcdf.CFDisposedException">Raised when visiting items of a closed compound file</exception>
             <param name="action">User <see cref="T:OpenMcdf.VisitedEntryAction">action</see> to apply to visited entities</param>
             <param name="recursive"> Visiting recursion level. True means substorages are visited recursively, false indicates that only the direct children of this storage are visited</param>
             <example>
             <code>
             const String STORAGE_NAME = "report.xls";
             CompoundFile cf = new CompoundFile(STORAGE_NAME);
            
             FileStream output = new FileStream("LogEntries.txt", FileMode.Create);
             TextWriter tw = new StreamWriter(output);
            
             VisitedEntryAction va = delegate(CFItem item)
             {
                 tw.WriteLine(item.Name);
             };
            
             cf.RootStorage.VisitEntries(va, true);
            
             tw.Close();
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CFStorage.Delete(System.String)">
            <summary>
            Remove an entry from the current storage and compound file.
            </summary>
            <param name="entryName">The name of the entry in the current storage to delete</param>
            <example>
            <code>
            cf = new CompoundFile("A_FILE_YOU_CAN_CHANGE.cfs", UpdateMode.Update, true, false);
            cf.RootStorage.Delete("AStream"); // AStream item is assumed to exist.
            cf.Commit(true);
            cf.Close();
            </code>
            </example>
            <exception cref="T:OpenMcdf.CFDisposedException">Raised if trying to delete item from a closed compound file</exception>
            <exception cref="T:OpenMcdf.CFItemNotFound">Raised if item to delete is not found</exception>
            <exception cref="T:OpenMcdf.CFException">Raised if trying to delete root storage</exception>
        </member>
        <member name="M:OpenMcdf.DirectoryEntry.fnv_hash(System.Byte[])">
            <summary>
            FNV hash, short for Fowler/Noll/Vo
            </summary>
            <param name="buffer"></param>
            <returns>(not warranted) unique hash for byte array</returns>
        </member>
        <member name="P:OpenMcdf.Header.FirstMiniFATSectorID">
            <summary>
            This integer field contains the starting sector number for the mini FAT
            </summary>
        </member>
        <member name="F:OpenMcdf.Header.OLE_CFS_SIGNATURE">
            <summary>
            Structured Storage signature
            </summary>
        </member>
        <member name="T:OpenMcdf.CFStream">
            <summary>
            OLE structured storage <see cref="T:OpenMcdf.CFStream">stream</see> Object
            It is contained inside a Storage object in a file-directory
            relationship and indexed by its name.
            </summary>
        </member>
        <member name="M:OpenMcdf.CFStream.SetData(System.Byte[])">
            <summary>
            Set the data associated with the stream object.
            </summary>
            <example>
            <code>
               byte[] b = new byte[]{0x0,0x1,0x2,0x3};
               CompoundFile cf = new CompoundFile();
               CFStream myStream = cf.RootStorage.AddStream("MyStream");
               myStream.SetData(b);
            </code>
            </example>
            <param name="data">Data bytes to write to this stream</param>
            <remarks>Existing associated data will be lost after method invocation</remarks>
        </member>
        <member name="M:OpenMcdf.CFStream.Write(System.Byte[],System.Int64)">
            <summary>
            Write a data buffer to a specific position into current CFStream object
            </summary>
            <param name="data">Data buffer to Write</param>
            <param name="position">Position into the stream object to start writing from</param>
            <remarks>Current stream will be extended to receive data buffer over 
            its current size</remarks>
        </member>
        <member name="M:OpenMcdf.CFStream.Write(System.Byte[],System.Int64,System.Int32,System.Int32)">
            <summary>
            Write <paramref name="count">count</paramref> bytes of a data buffer to a specific position into 
            the current CFStream object starting from the specified position.
            </summary>
            <param name="data">Data buffer to copy bytes from</param>
            <param name="position">Position into the stream object to start writing from</param>
            <param name="offset">The zero-based byte offset in buffer at which to 
            begin copying bytes to the current <see cref="T:OpenMcdf.CFStream">CFStream</see>. </param>
            <param name="count">The number of bytes to be written to the current <see cref="T:OpenMcdf.CFStream">CFStream</see> </param>
            <remarks>Current stream will be extended to receive data buffer over 
            its current size.</remarks>
        </member>
        <member name="M:OpenMcdf.CFStream.Append(System.Byte[])">
            <summary>
            Append the provided data to stream data.
            </summary>
            <example>
            <code>
               byte[] b = new byte[]{0x0,0x1,0x2,0x3};
               byte[] b2 = new byte[]{0x4,0x5,0x6,0x7};
               CompoundFile cf = new CompoundFile();
               CFStream myStream = cf.RootStorage.AddStream("MyStream");
               myStream.SetData(b); // here we could also have invoked .AppendData
               myStream.AppendData(b2);
               cf.Save("MyLargeStreamsFile.cfs);
               cf.Close();
            </code>
            </example>
            <param name="data">Data bytes to append to this stream</param>
            <remarks>
            This method allows user to create stream with more than 2GB of data, 
            appending data to the end of existing ones.
            Large streams (>2GB) are only supported by CFS version 4.
            Append data can also be invoked on streams with no data in order
            to simplify its use inside loops.
            </remarks>
        </member>
        <member name="M:OpenMcdf.CFStream.GetData">
            <summary>
            Get all the data associated with the stream object.
            </summary>
            <example>
            <code>
                CompoundFile cf2 = new CompoundFile("AFileName.cfs");
                CFStream st = cf2.RootStorage.GetStream("MyStream");
                byte[] buffer = st.ReadAll();
            </code>
            </example>
            <returns>Array of byte containing stream data</returns>
            <exception cref="T:OpenMcdf.CFDisposedException">
            Raised when the owner compound file has been closed.
            </exception>
        </member>
        <!-- Commento XML in formato non corretto ignorato per il membro 'M:OpenMcdf.CFStream.Read(System.Byte[],System.Int64,System.Int32)' -->
        <!-- Commento XML in formato non corretto ignorato per il membro 'M:OpenMcdf.CFStream.Read(System.Byte[],System.Int64,System.Int32,System.Int32)' -->
        <member name="M:OpenMcdf.CFStream.CopyFrom(System.IO.Stream)">
            <summary>
            Copy data from an existing stream.
            </summary>
            <param name="input">A stream to read from</param>
            <remarks>
            Input stream will NOT be closed after method invocation.
            Existing associated data will be deleted.
            </remarks>
        </member>
        <member name="M:OpenMcdf.CFStream.Resize(System.Int64)">
            <summary>
            Resize stream padding with zero if enlarging, trimming data if reducing size.
            </summary>
            <param name="length">New length to assign to this stream</param>
        </member>
        <member name="T:OpenMcdf.Ver3SizeLimitReached">
            <summary>
            Action to implement when transaction support - sector
            has to be written to the underlying stream (see specs).
            </summary>
        </member>
        <member name="T:OpenMcdf.SectorCollection">
            <summary>
            Ad-hoc Heap Friendly sector collection to avoid using 
            large array that may create some problem to GC collection 
            (see http://www.simple-talk.com/dotnet/.net-framework/the-dangers-of-the-large-object-heap/ )
            </summary>
        </member>
        <member name="T:OpenMcdf.CFSConfiguration">
            <summary>
            Configuration parameters for the compund files.
            They can be OR-combined to configure 
            <see cref="T:OpenMcdf.CompoundFile">Compound file</see> behaviour.
            All flags are NOT set by Default.
            </summary>
        </member>
        <member name="F:OpenMcdf.CFSConfiguration.Default">
            <summary>
            Sector Recycling turn off, 
            free sectors erasing off, 
            format validation exception raised
            </summary>
        </member>
        <member name="F:OpenMcdf.CFSConfiguration.SectorRecycle">
            <summary>
            Sector recycling reduces data writing performances 
            but avoids space wasting in scenarios with frequently
            data manipulation of the same streams.
            </summary>
        </member>
        <member name="F:OpenMcdf.CFSConfiguration.EraseFreeSectors">
            <summary>
            Free sectors are erased to avoid information leakage
            </summary>
        </member>
        <member name="F:OpenMcdf.CFSConfiguration.NoValidationException">
            <summary>
            No exception is raised when a validation error occurs.
            This can possibly lead to a security issue but gives 
            a chance to corrupted files to load.
            </summary>
        </member>
        <member name="F:OpenMcdf.CFSConfiguration.LeaveOpen">
            <summary>
            If this flag is set true,
            backing stream is kept open after CompoundFile disposal
            </summary>
        </member>
        <member name="T:OpenMcdf.CFSVersion">
            <summary>
            Binary File Format Version. Sector size  is 512 byte for version 3,
            4096 for version 4
            </summary>
        </member>
        <member name="F:OpenMcdf.CFSVersion.Ver_3">
            <summary>
            Compound file version 3 - The default and most common version available. Sector size 512 bytes, 2GB max file size.
            </summary>
        </member>
        <member name="F:OpenMcdf.CFSVersion.Ver_4">
            <summary>
            Compound file version 4 - Sector size is 4096 bytes. Using this version could bring some compatibility problem with existing applications.
            </summary>
        </member>
        <member name="T:OpenMcdf.CFSUpdateMode">
            <summary>
            Update mode of the compound file.
            Default is ReadOnly.
            </summary>
        </member>
        <member name="F:OpenMcdf.CFSUpdateMode.ReadOnly">
            <summary>
            ReadOnly update mode prevents overwriting
            of the opened file. 
            Data changes are allowed but they have to be 
            persisted on a different file when required 
            using <see cref="M:OpenMcdf.CompoundFile.Save">method</see>
            </summary>
        </member>
        <member name="F:OpenMcdf.CFSUpdateMode.Update">
            <summary>
            Update mode allows subsequent data changing operations
            to be persisted directly on the opened file or stream
            using the <see cref="M:OpenMcdf.CompoundFile.Commit">Commit</see>
            method when required. Warning: this option may cause existing data loss if misused.
            </summary>
        </member>
        <member name="T:OpenMcdf.CompoundFile">
            <summary>
            Standard Microsoft&#169; Compound File implementation.
            It is also known as OLE/COM structured storage 
            and contains a hierarchy of storage and stream objects providing
            efficent storage of multiple kinds of documents in a single file.
            Version 3 and 4 of specifications are supported.
            </summary>
        </member>
        <member name="P:OpenMcdf.CompoundFile.Configuration">
            <summary>
            Get the configuration parameters of the CompoundFile object.
            </summary>
        </member>
        <member name="M:OpenMcdf.CompoundFile.GetSectorSize">
            <summary>
            Returns the size of standard sectors switching on CFS version (3 or 4)
            </summary>
            <returns>Standard sector size</returns>
        </member>
        <member name="F:OpenMcdf.CompoundFile.HEADER_DIFAT_ENTRIES_COUNT">
            <summary>
            Number of DIFAT entries in the header
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.DIFAT_SECTOR_FAT_ENTRIES_COUNT">
            <summary>
            Number of FAT entries in a DIFAT Sector
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.FAT_SECTOR_ENTRIES_COUNT">
            <summary>
            Sectors ID entries in a FAT Sector
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.SIZE_OF_SID">
            <summary>
            Sector ID Size (int)
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.sectorRecycle">
            <summary>
            Flag for sector recycling.
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.eraseFreeSectors">
            <summary>
            Flag for unallocated sector zeroing out.
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.FLUSHING_QUEUE_SIZE">
            <summary>
            Initial capacity of the flushing queue used
            to optimize commit writing operations
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.FLUSHING_BUFFER_MAX_SIZE">
            <summary>
            Maximum size of the flushing buffer used
            to optimize commit writing operations
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.header">
            <summary>
            CompoundFile header
            </summary>
        </member>
        <member name="F:OpenMcdf.CompoundFile.sourceStream">
            <summary>
            Compound underlying stream. Null when new CF has been created.
            </summary>
        </member>
        <member name="M:OpenMcdf.CompoundFile.#ctor">
             <summary>
             Create a blank, version 3 compound file.
             Sector recycle is turned off to achieve the best reading/writing 
             performance in most common scenarios.
             </summary>
             <example>
             <code>
             
                 byte[] b = new byte[10000];
                 for (int i = 0; i &lt; 10000; i++)
                 {
                     b[i % 120] = (byte)i;
                 }
            
                 CompoundFile cf = new CompoundFile();
                 CFStream myStream = cf.RootStorage.AddStream("MyStream");
            
                 Assert.IsNotNull(myStream);
                 myStream.SetData(b);
                 cf.Save("MyCompoundFile.cfs");
                 cf.Close();
                 
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CompoundFile.#ctor(OpenMcdf.CFSVersion,OpenMcdf.CFSConfiguration)">
             <summary>
             Create a new, blank, compound file.
             </summary>
             <param name="cfsVersion">Use a specific Compound File Version to set 512 or 4096 bytes sectors</param>
             <param name="configFlags">Set <see cref="T:OpenMcdf.CFSConfiguration">configuration</see> parameters for the new compound file</param>
             <example>
             <code>
             
                 byte[] b = new byte[10000];
                 for (int i = 0; i &lt; 10000; i++)
                 {
                     b[i % 120] = (byte)i;
                 }
            
                 CompoundFile cf = new CompoundFile(CFSVersion.Ver_4, CFSConfiguration.Default);
                 CFStream myStream = cf.RootStorage.AddStream("MyStream");
            
                 Assert.IsNotNull(myStream);
                 myStream.SetData(b);
                 cf.Save("MyCompoundFile.cfs");
                 cf.Close();
                 
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CompoundFile.#ctor(System.String)">
             <summary>
             Load an existing compound file.
             </summary>
             <param name="fileName">Compound file to read from</param>
             <example>
             <code>
             //A xls file should have a Workbook stream
             String filename = "report.xls";
            
             CompoundFile cf = new CompoundFile(filename);
             CFStream foundStream = cf.RootStorage.GetStream("Workbook");
            
             byte[] temp = foundStream.GetData();
            
             Assert.IsNotNull(temp);
            
             cf.Close();
             </code>
             </example>
             <remarks>
             File will be open in read-only mode: it has to be saved
             with a different filename. A wrapping implementation has to be provided 
             in order to remove/substitute an existing file. Version will be
             automatically recognized from the file. Sector recycle is turned off
             to achieve the best reading/writing performance in most common scenarios.
             </remarks>
        </member>
        <member name="M:OpenMcdf.CompoundFile.#ctor(System.String,OpenMcdf.CFSUpdateMode,OpenMcdf.CFSConfiguration)">
             <summary>
             Load an existing compound file.
             </summary>
             <param name="fileName">Compound file to read from</param>
             <param name="sectorRecycle">If true, recycle unused sectors</param>
             <param name="updateMode">Select the update mode of the underlying data file</param>
             <param name="eraseFreeSectors">If true, overwrite with zeros unallocated sectors</param>
             <example>
             <code>
             String srcFilename = "data_YOU_CAN_CHANGE.xls";
             
             CompoundFile cf = new CompoundFile(srcFilename, UpdateMode.Update, true, true);
            
             Random r = new Random();
            
             byte[] buffer = GetBuffer(r.Next(3, 4095), 0x0A);
            
             cf.RootStorage.AddStream("MyStream").SetData(buffer);
             
             //This will persist data to the underlying media.
             cf.Commit();
             cf.Close();
            
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CompoundFile.#ctor(System.IO.Stream,OpenMcdf.CFSUpdateMode,OpenMcdf.CFSConfiguration)">
             <summary>
             Load an existing compound file.
             </summary>
             <param name="stream">A stream containing a compound file to read</param>
             <param name="sectorRecycle">If true, recycle unused sectors</param>
             <param name="updateMode">Select the update mode of the underlying data file</param>
             <param name="eraseFreeSectors">If true, overwrite with zeros unallocated sectors</param>
             <example>
             <code>
             
             String filename = "reportREAD.xls";
               
             FileStream fs = new FileStream(filename, FileMode.Open);
             CompoundFile cf = new CompoundFile(fs, UpdateMode.ReadOnly, false, false);
             CFStream foundStream = cf.RootStorage.GetStream("Workbook");
            
             byte[] temp = foundStream.GetData();
            
             Assert.IsNotNull(temp);
            
             cf.Close();
            
             </code>
             </example>
             <exception cref="T:OpenMcdf.CFException">Raised when trying to open a non-seekable stream</exception>
             <exception cref="T:OpenMcdf.CFException">Raised stream is null</exception>
        </member>
        <member name="M:OpenMcdf.CompoundFile.#ctor(System.IO.Stream)">
             <summary>
             Load an existing compound file from a stream.
             </summary>
             <param name="stream">Streamed compound file</param>
             <example>
             <code>
             
             String filename = "reportREAD.xls";
               
             FileStream fs = new FileStream(filename, FileMode.Open);
             CompoundFile cf = new CompoundFile(fs);
             CFStream foundStream = cf.RootStorage.GetStream("Workbook");
            
             byte[] temp = foundStream.GetData();
            
             Assert.IsNotNull(temp);
            
             cf.Close();
            
             </code>
             </example>
             <exception cref="T:OpenMcdf.CFException">Raised when trying to open a non-seekable stream</exception>
             <exception cref="T:OpenMcdf.CFException">Raised stream is null</exception>
        </member>
        <member name="M:OpenMcdf.CompoundFile.Commit">
            <summary>
            Commit data changes since the previously commit operation
            to the underlying supporting stream or file on the disk.
            </summary>
            <remarks>
            This method can be used
            only if the supporting stream has been opened in 
            <see cref="T:OpenMcdf.UpdateMode">Update mode</see>.
            </remarks>
        </member>
        <member name="M:OpenMcdf.CompoundFile.Commit(System.Boolean)">
            <summary>
            Commit data changes since the previously commit operation
            to the underlying supporting stream or file on the disk.
            </summary>
            <param name="releaseMemory">If true, release loaded sectors to limit memory usage but reduces following read operations performance</param>
            <remarks>
            This method can be used only if 
            the supporting stream has been opened in 
            <see cref="T:OpenMcdf.UpdateMode">Update mode</see>.
            </remarks>
        </member>
        <member name="M:OpenMcdf.CompoundFile.Load(System.IO.Stream)">
            <summary>
            Load compound file from an existing stream.
            </summary>
            <param name="stream">Stream to load compound file from</param>
        </member>
        <member name="P:OpenMcdf.CompoundFile.HasSourceStream">
            <summary>
            Return true if this compound file has been 
            loaded from an existing file or stream
            </summary>
        </member>
        <member name="M:OpenMcdf.CompoundFile.AllocateMiniSectorChain(System.Collections.Generic.List{OpenMcdf.Sector})">
            <summary>
            Allocate space, setup sectors id and refresh header
            for the new or updated mini sector chain.
            </summary>
            <param name="sectorChain">The new MINI sector chain</param>
        </member>
        <member name="M:OpenMcdf.CompoundFile.SetSectorChain(System.Collections.Generic.List{OpenMcdf.Sector})">
            <summary>
            Allocate space, setup sectors id in the FAT and refresh header
            for the new or updated sector chain (Normal or Mini sectors)
            </summary>
            <param name="sectorChain">The new or updated normal or mini sector chain</param>
        </member>
        <member name="M:OpenMcdf.CompoundFile.AllocateSectorChain(System.Collections.Generic.List{OpenMcdf.Sector})">
            <summary>
            Allocate space, setup sectors id and refresh header
            for the new or updated sector chain.
            </summary>
            <param name="sectorChain">The new or updated generic sector chain</param>
        </member>
        <member name="M:OpenMcdf.CompoundFile.CheckForLockSector">
            <summary>
            Check for transaction lock sector addition and mark it in the FAT.
            </summary>
        </member>
        <member name="M:OpenMcdf.CompoundFile.AllocateFATSectorChain(System.Collections.Generic.List{OpenMcdf.Sector})">
            <summary>
            Allocate space, setup sectors id and refresh header
            for the new or updated FAT sector chain.
            </summary>
            <param name="sectorChain">The new or updated generic sector chain</param>
        </member>
        <member name="M:OpenMcdf.CompoundFile.AllocateDIFATSectorChain(System.Collections.Generic.List{OpenMcdf.Sector})">
            <summary>
            Setup the DIFAT sector chain
            </summary>
            <param name="FATsectorChain">A FAT sector chain</param>
        </member>
        <member name="M:OpenMcdf.CompoundFile.GetDifatSectorChain">
            <summary>
            Get the DIFAT Sector chain
            </summary>
            <returns>A list of DIFAT sectors</returns>
        </member>
        <member name="M:OpenMcdf.CompoundFile.GetFatSectorChain">
            <summary>
            Get the FAT sector chain
            </summary>
            <returns>List of FAT sectors</returns>
        </member>
        <member name="M:OpenMcdf.CompoundFile.GetNormalSectorChain(System.Int32)">
            <summary>
            Get a standard sector chain
            </summary>
            <param name="secID">First SecID of the required chain</param>
            <returns>A list of sectors</returns>
        </member>
        <member name="M:OpenMcdf.CompoundFile.GetMiniSectorChain(System.Int32)">
            <summary>
            Get a mini sector chain
            </summary>
            <param name="secID">First SecID of the required chain</param>
            <returns>A list of mini sectors (64 bytes)</returns>
        </member>
        <member name="M:OpenMcdf.CompoundFile.GetSectorChain(System.Int32,OpenMcdf.SectorType)">
            <summary>
            Get a sector chain from a compound file given the first sector ID
            and the required sector type.
            </summary>
            <param name="secID">First chain sector's id </param>
            <param name="chainType">Type of Sectors in the required chain (mini sectors, normal sectors or FAT)</param>
            <returns>A list of Sectors as the result of their concatenation</returns>
        </member>
        <member name="P:OpenMcdf.CompoundFile.RootStorage">
             <summary>
             The entry point object that represents the 
             root of the structures tree to get or set storage or
             stream data.
             </summary>
             <example>
             <code>
             
                //Create a compound file
                string FILENAME = "MyFileName.cfs";
                CompoundFile ncf = new CompoundFile();
            
                CFStorage l1 = ncf.RootStorage.AddStorage("Storage Level 1");
            
                l1.AddStream("l1ns1");
                l1.AddStream("l1ns2");
                l1.AddStream("l1ns3");
                CFStorage l2 = l1.AddStorage("Storage Level 2");
                l2.AddStream("l2ns1");
                l2.AddStream("l2ns2");
            
                ncf.Save(FILENAME);
                ncf.Close();
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CompoundFile.ResetDirectoryEntry(System.Int32)">
            <summary>
            Reset a directory entry setting it to StgInvalid in the Directory.
            </summary>
            <param name="sid">Sid of the directory to invalidate</param>
        </member>
        <member name="M:OpenMcdf.CompoundFile.LoadDirectories">
            <summary>
            Load directory entries from compound file. Header and FAT MUST be already loaded.
            </summary>
        </member>
        <member name="M:OpenMcdf.CompoundFile.CommitDirectory">
            <summary>
             Commit directory entries change on the Current Source stream
            </summary>
        </member>
        <member name="M:OpenMcdf.CompoundFile.Save(System.String)">
            <summary>
            Saves the in-memory image of Compound File to a file.
            </summary>
            <param name="fileName">File name to write the compound file to</param>
            <exception cref="T:OpenMcdf.CFException">Raised if destination file is not seekable</exception>
        </member>
        <member name="M:OpenMcdf.CompoundFile.Save(System.IO.Stream)">
             <summary>
             Saves the in-memory image of Compound File to a stream.
             </summary>        
             <remarks>
             Destination Stream must be seekable. Uncommitted data will be persisted to the destination stream.
             </remarks>
             <param name="stream">The stream to save compound File to</param>
             <exception cref="T:OpenMcdf.CFException">Raised if destination stream is not seekable</exception>
             <exception cref="T:OpenMcdf.CFDisposedException">Raised if Compound File Storage has been already disposed</exception>
             <example>
             <code>
                MemoryStream ms = new MemoryStream(size);
            
                CompoundFile cf = new CompoundFile();
                CFStorage st = cf.RootStorage.AddStorage("MyStorage");
                CFStream sm = st.AddStream("MyStream");
            
                byte[] b = new byte[]{0x00,0x01,0x02,0x03};
            
                sm.SetData(b);
                cf.Save(ms);
                cf.Close();
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CompoundFile.FindFreeSectors(OpenMcdf.SectorType)">
            <summary>
            Scan FAT o miniFAT for free sectors to reuse.
            </summary>
            <param name="sType">Type of sector to look for</param>
            <returns>A Queue of available sectors or minisectors already allocated</returns>
        </member>
        <!-- Commento XML in formato non corretto ignorato per il membro 'M:OpenMcdf.CompoundFile.AppendData(OpenMcdf.CFItem,System.Byte[])' -->
        <member name="M:OpenMcdf.CompoundFile.SetStreamLength(OpenMcdf.CFItem,System.Int64)">
            <summary>
            Resize stream length
            </summary>
            <param name="cfItem"></param>
            <param name="length"></param>
        </member>
        <member name="M:OpenMcdf.CompoundFile.CheckFileLength">
            <summary>
            Check file size limit ( 2GB for version 3 )
            </summary>
        </member>
        <member name="M:OpenMcdf.CompoundFile.Close">
             <summary>
             Close the Compound File object <see cref="T:OpenMcdf.CompoundFile">CompoundFile</see> and
             free all associated resources (e.g. open file handle and allocated memory).
             <remarks>
             When the <see cref="T:OpenMcdf.CompoundFile.Close()">Close</see> method is called,
             all the associated stream and storage objects are invalidated:
             any operation invoked on them will produce a <see cref="T:OpenMcdf.CFDisposedException">CFDisposedException</see>.
             </remarks>
             </summary>
             <example>
             <code>
                const String FILENAME = "CompoundFile.cfs";
                CompoundFile cf = new CompoundFile(FILENAME);
            
                CFStorage st = cf.RootStorage.GetStorage("MyStorage");
                cf.Close();
            
                try
                {
                    byte[] temp = st.GetStream("MyStream").GetData();
                    
                    // The following line will fail because back-end object has been closed
                    Assert.Fail("Stream without media");
                }
                catch (Exception ex)
                {
                    Assert.IsTrue(ex is CFDisposedException);
                }
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CompoundFile.Dispose(System.Boolean)">
            <summary>
            When called from user code, release all resources, otherwise, in the case runtime called it,
            only unmanagd resources are released.
            </summary>
            <param name="disposing">If true, method has been called from User code, if false it's been called from .net runtime</param>
        </member>
        <member name="M:OpenMcdf.CompoundFile.GetAllNamedEntries(System.String)">
            <summary>
            Get a list of all entries with a given name contained in the document.
            </summary>
            <param name="entryName">Name of entries to retrive</param>
            <returns>A list of name-matching entries</returns>
            <remarks>This function is aimed to speed up entity lookup in 
            flat-structure files (only one or little more known entries)
            without the performance penalty related to entities hierarchy constraints.
            There is no implied hierarchy in the returned list.
            </remarks>
        </member>
        <member name="M:OpenMcdf.CompoundFile.ShrinkCompoundFile(System.IO.Stream)">
             <summary>
             Compress free space by removing unallocated sectors from compound file
             effectively reducing stream or file size.
             </summary>
             <remarks>
             Current implementation supports compression only for ver. 3 compound files.
             </remarks>
             <example>
             <code>
             
              //This code has been extracted from unit test
              
                String FILENAME = "MultipleStorage3.cfs";
            
                FileInfo srcFile = new FileInfo(FILENAME);
            
                File.Copy(FILENAME, "MultipleStorage_Deleted_Compress.cfs", true);
            
                CompoundFile cf = new CompoundFile("MultipleStorage_Deleted_Compress.cfs", UpdateMode.Update, true, true);
            
                CFStorage st = cf.RootStorage.GetStorage("MyStorage");
                st = st.GetStorage("AnotherStorage");
                
                Assert.IsNotNull(st);
                st.Delete("Another2Stream"); //17Kb
                cf.Commit();
                cf.Close();
            
                CompoundFile.ShrinkCompoundFile("MultipleStorage_Deleted_Compress.cfs");
            
                FileInfo dstFile = new FileInfo("MultipleStorage_Deleted_Compress.cfs");
            
                Assert.IsTrue(srcFile.Length > dstFile.Length);
            
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CompoundFile.ShrinkCompoundFile(System.String)">
             <summary>
             Remove unallocated sectors from compound file in order to reduce its size.
             </summary>
             <remarks>
             Current implementation supports compression only for ver. 3 compound files.
             </remarks>
             <example>
             <code>
             
              //This code has been extracted from unit test
              
                String FILENAME = "MultipleStorage3.cfs";
            
                FileInfo srcFile = new FileInfo(FILENAME);
            
                File.Copy(FILENAME, "MultipleStorage_Deleted_Compress.cfs", true);
            
                CompoundFile cf = new CompoundFile("MultipleStorage_Deleted_Compress.cfs", UpdateMode.Update, true, true);
            
                CFStorage st = cf.RootStorage.GetStorage("MyStorage");
                st = st.GetStorage("AnotherStorage");
                
                Assert.IsNotNull(st);
                st.Delete("Another2Stream"); //17Kb
                cf.Commit();
                cf.Close();
            
                CompoundFile.ShrinkCompoundFile("MultipleStorage_Deleted_Compress.cfs");
            
                FileInfo dstFile = new FileInfo("MultipleStorage_Deleted_Compress.cfs");
            
                Assert.IsTrue(srcFile.Length > dstFile.Length);
            
             </code>
             </example>
        </member>
        <member name="M:OpenMcdf.CompoundFile.DoCompression(OpenMcdf.CFStorage,OpenMcdf.CFStorage)">
            <summary>
            Recursively clones valid structures, avoiding to copy free sectors.
            </summary>
            <param name="currSrcStorage">Current source storage to clone</param>
            <param name="currDstStorage">Current cloned destination storage</param>
        </member>
        <member name="M:OpenMcdf.Sector.Dispose(System.Boolean)">
            <summary>
            When called from user code, release all resources, otherwise, in the case runtime called it,
            only unmanagd resources are released.
            </summary>
            <param name="disposing">If true, method has been called from User code, if false it's been called from .net runtime</param>
        </member>
        <member name="T:OpenMcdf.StreamView">
            <summary>
            Stream decorator for a Sector or miniSector chain
            </summary>
        </member>
        <member name="T:RedBlackTree.IRBNode">
            <summary>
            Red Black Node interface
            </summary>
        </member>
    </members>
</doc>
